/*
 Copyright 2013 Intel Corporation. All rights reserved.
 
 Dependencies:
 prototype.js
 log.js
 form.js
 rivets.js
 */

/* globals: $, $$, Ajax, Object, TypeError, URI, XMLHttpRequest, document, fakeresource, log, mtwilson, rivets */
/*jslint white: true */

if (mtwilson === undefined) {
    var mtwilson = {};
}

loadTagsCall = true;
loadSelsCall = true;
disable_sel_render = false;
var pres_selections;
//var mtwilson = mtwilson || {};
mtwilson.atag = mtwilson.atag || {};
(function() { // start mt wilson asset tag module definition

    // base url
    var uri = "/AttestationService/resources"; //new URI(document.location.toString());

    // DATA
    var data;
    var view;
    var options;

    // must be called after DOM is loaded;  application typically should do document.observe("dom:loaded", function() { ws.initialize(params); });
    mtwilson.atag.initialize = function(parameters) {
        data = parameters.data || {
            'notices': [], // each has { text:'', clear:'auto' }  (or clear:'confirm' to force user to acknowledge it)  generally generated by the client
            'tags': [], // each has { name:'', oid:'', values:[] }
            'unfiltered_tags': [], // each has { name:'', oid:'', values:[] }
            'rearranged_tags': [], // each has { name:'', oid:'', values:[] }
            'selections': [],
            'unfiltered_sels': [],
            'certificateRequests': [],
            'certificates': [],
            'revokeCertificates': [], // tentative, see revokeCertificate()
            'provisionCertificates': [], // tentative, see provisionCertificate()
            'rdfTriples': [],
            'configurations': [],
            'files': [],
			'hosts': [],
            'selection_details': [],
            'currentConfiguration': {}
        };
        log.debug("init data to " + Object.toJSON(data));
        ajax.data = data;
        mtwilson.atag.data = data;
        view = parameters.view || {
            'update': function(data) {
                var array = mtwilson.rivets.views.keys(); // until they respond we don't know what these tags are;  
                var i = array.length;
                log.debug("Updating " + i + " views");
                while (i--) {
                    mtwilson.rivets.views[array[i]].update(data);
                }
            },
            'sync': function() {
                var array = mtwilson.rivets.views.keys(); // until they respond we don't know what these tags are;  
                var i = array.length;
                log.debug("Synchronizing " + i + " views");
                while (i--) {
                    log.debug("Synchronizing " + array[i] + " view" + mtwilson.rivets.views[array[i]]);
                    mtwilson.rivets.views[array[i]].sync();
                }
            }
        };



        mtwilson.atag.view = view;
        ajax.view = view; // after every ajax call the view will be updated ???
        options = parameters.options || {
            'baseurl': (uri.scheme() == 'http' || uri.scheme() == 'https') ? '' : '#' // or http://localhost:8080
        };

        mtwilson.rivets = {};
        mtwilson.rivets.forms = {};
        mtwilson.rivets.views = {};
        // find all forms, and automatically create a data object for each one to use in binding
        var forms = $$('form[id]');
        log.debug("Found " + forms.length + " forms to bind");
        var i = forms.length, formId;
        while (i--) {
            formId = forms[i].id;
            log.debug("Creating form data area: " + formId);
            // create a data object for the form
            mtwilson.rivets.forms[ formId ] = {'global': mtwilson.atag.data, 'input': {}}; // give every form a link to global data (not included when the form is submitted) and an input area (for data to submit)
            // use rivets to bind the object to the form
            mtwilson.rivets.views[ formId ] = rivets.bind(forms[i], mtwilson.rivets.forms[formId]);
        }

        var dataviews = $$('.dataview');
        log.debug("Found " + dataviews.length + " dataviews to bind");
        var elementId;
        i = dataviews.length;
        while (i--) {
            elementId = dataviews[i].id; 
            log.debug("Creating view data area: " + elementId);
            mtwilson.rivets.views[ elementId ] = rivets.bind(dataviews[i], mtwilson.atag.data);
        }
        
        var tabledisplaybind = $$('.tableDisplayBind');
        log.debug("Found " + tabledisplaybind.length + " tabledisplaybind to bind");
        var elementId;
        i = tabledisplaybind.length;
        while (i--) {
            elementId = tabledisplaybind[i].id; 
            log.debug("Creating tabledisplaybind area: " + elementId);
            mtwilson.rivets.views[ elementId ] = rivets.bind(tabledisplaybind[i], mtwilson.atag.data);
        }

//        mtwilson.atag.view.sync();

        // fire an event to let the application know that we're done initializing
        document.fire("mtwilson:ready", {});


        /*
         * VIEWS maps name (tags, requests, certificates, rdf-triples) to view objects.
         * Each view object should have an update(data) function which will be called
         * whenever our data is updated.
         */
//VIEWS = parameters.views || {};
    };



    // configure the ajax framework
    // NOTE:   /mtwilson-portal/v2proxy  gets translated to /mtwilson/v2  but with the logged-in portal user's credentials (otherwise service would respond with 401 unauthorized)
    ajax.resources.notices = {uri: '/notices', datapath: 'notices', idkey: 'uuid'}; 
    ajax.resources.tags = {uri: '/mtwilson-portal/v2proxy/tag-kv-attributes', datapath: 'tags', idkey: 'id'}; // configurations can also use idkey:'oid' and idkey:'name' 
    ajax.resources.tags_json = {uri: '/mtwilson-portal/v2proxy/tag-kv-attributes.json', datapath: 'tags', elementsName: 'kv_attributes', idkey: 'id'}; // configurations can also use idkey:'oid' and idkey:'name' 
    ajax.resources.unfiltered_tags = {uri: '/mtwilson-portal/v2proxy/tag-kv-attributes.json', datapath: 'unfiltered_tags', idkey: 'id', elementsName: 'kv_attributes'}; // configurations can also use idkey:'oid' and idkey:'name' 
    //ajax.resources.unfiltered_tags = {uri: '/tags', datapath: 'tags', idkey: 'uuid'}; // configurations can also use idkey:'oid' and idkey:'name' 
    ajax.resources.rdfTriples = {uri: '/rdf-triples', datapath: 'rdfTriples', idkey: 'uuid'};
    //ajax.resources.certificates = {uri: '/certificates', datapath: 'certificates', idkey: 'uuid'};
    ajax.resources.certificates_json = {uri: '/AttestationService/resources/tag-certificates', datapath: 'certificates', elementsName: 'certificates', idkey: 'id'};
    ajax.resources.certificates = {uri: '/AttestationService/resources/tag-certificates', datapath: 'certificates', elementsName: 'certificates', idkey: 'id'};
    ajax.resources.certificateRequests = {uri: '/AttestationService/resources/tag-certificate-requests-rpc/provision', datapath: 'certificateRequests', idkey: 'uuid'};
    ajax.resources.selections_json = {uri: '/mtwilson-portal/v2proxy/tag-selections.json', datapath: 'selections', elementsName: 'selections',  idkey: 'id'}; // selections can also use idkey:'name'
    ajax.resources.selections = {uri: '/mtwilson-portal/v2proxy/tag-selections', idkey: 'id'}; // selections can also use idkey:'name'
    ajax.resources.unfiltered_sels = {uri: '/mtwilson-portal/v2proxy/tag-selections.json', datapath: 'unfiltered_sels', idkey: 'id', elementsName: 'selections'}; // selections can also use idkey:'name'
    ajax.resources.selection_kv_attributes = {uri: '/mtwilson-portal/v2proxy/tag-selection-kv-attributes.json', datapath: 'selection_details', idkey: 'id', elementsName: 'selection_kv_attribute_values'}; // selections can also use idkey:'name'
    ajax.resources.configurations = {uri: '/mtwilson-portal/v2proxy/configurations', datapath: 'configurations', idkey: 'uuid'}; // configurations can also use idkey:'name'
    ajax.resources.files = {uri: '/files', datapath: 'files', idkey: 'uuid'}; // configurations can also use idkey:'name'
    ajax.resources.uuid = {uri: '/host-uuids', datapath: 'uuid', idkey: null};
	ajax.resources.hosts = {uri: '/mtwilson-portal/v2proxy/hosts.json', datapath: 'hosts', elementsName: 'hosts', idkey: 'id'};
//    mtwilson.atag.data = data; 
//    log.debug("again, data = "+Object.toJSON(mtwilson.atag.data));
// UTILITIES

    /**
     * Uses validator.js to validate form input. Conveniently accepts form id, form element, or form child element to identify
     * the form to validate.
     *
     * @param input can be a form id (string), html form element, or any html element inside the form such as a submit button
     * @return an object { validator: Validator, input: input-model, isValid: boolean }
     */
    function validate(input) {
        var formId;
        var validator;
        var model;
        var isValid = false;
        if (typeof input === 'string') {  // the id of a form
            formId = input;
        }
        console.log("input var is: " + input);
        if (Object.isElement(input) && input.tagName.toLowerCase() == 'form') { // an html form, so use its id
            formId = input.id;
        }
        else if (Object.isElement(input)) { // an html element but not the form... so move up to the enclosing form to get the id
            formId = input.up('form').id;
        }
        log.debug("getting model for form id " + formId + "  area: " + Object.toJSON(mtwilson.rivets.forms[formId]));
        model = mtwilson.rivets.forms[ formId ].input; // only validate the input area (not the global data area)
        log.debug("so the model is... " + Object.toJSON(model));
        validator = new Validation(formId, {
            useTitles: true,
            immediate: true,
            onSubmit: false
        });
        /*
         if( typeof input === 'object' ) {
         model = input;
         validator = null; 
         }
         */
        if (validator) {
            isValid = validator.validate();
        }
        log.debug("returning with input/model = " + Object.toJSON(model));
        return {'validator': validator, 'input': model, 'isValid': isValid, 'formId': formId};
    }


    function apiwait(text) {
        $('ajaxstatus').addClassName("wait");
        if (!text) {
            text = "Waiting...";
        }
        if (text) {
            $('ajaxstatus').update(text);
        }
//$('ajaxstatus').show();
    }
    function apidone() {
        //$('ajaxstatus').hide();
        $('ajaxstatus').removeClassName("wait");
        $('ajaxstatus').update("");
    }

    function apiurl(resource) {
        return options.baseurl + /* '/' + */ resource;
    }


    /*
     function view(resource) {
     if( resource in VIEWS ) {
     log.debug("There is a view for resource "+resource);
     if( 'update' in VIEWS[resource] ) {
     log.debug("Found view for "+resource);
     return VIEWS[resource];
     }
     }
     return { 'update': function() { log.debug("No view for resource '"+resource+"'"); } };
     }
     */
// SERVER REPOSITORY HELPER METHODS
    mtwilson.atag.notify = function(notice) {
        if ($('notifications')) {
            $('notifications').remove();
        }
        $('notifications_container').insert("<div id=\"notifications\" style=\"display: none;\" title=\"Click to close\"></div>");
        enableClickableAlerts();
        $('notifications').classNames().toArray().forEach(function(obj) {
            $('notifications').removeClassName(obj);
        });

        if (notice.status == null) {
            notice.status = "INFO";
            notice.default_status = true;
        }

        if (notice.clearAfter == null) {
            if (notice.status == "OK" || notice.status == "INFO") {
                notice.clearAfter = "AUTO";
            }
            else {
                notice.clearAfter = "CONFIRM";
            }
        }

        switch (notice.status) {
            case "OK":
                log.debug("OK: " + Object.toJSON(notice));
                $('notifications').addClassName('msgOK');
                break;
            case "INFO":
                log.debug("INFO: " + Object.toJSON(notice));
                $('notifications').addClassName('msgInfo');
                break;
            case "WARN":
                log.debug("WARN: " + Object.toJSON(notice));
                $('notifications').addClassName('msgWarn');
                break;
            case "ERROR":
                log.debug("ERROR: " + Object.toJSON(notice));
                $('notifications').addClassName('msgError');
                break;
            default:
                break;
        }
        $('notifications').update(notice.text);
        $('notifications').show();
        $('notifications').setOpacity(1.0);

        switch (notice.clearAfter) {
            case "AUTO":
                $('notifications').fade.bind($('notifications')).delay(5);
                break;
            case "CONFIRM":
                break;
            default:
                break;
        }
    };

// VIEW API
    document.observe("ajax:httpPostSuccess", function(event) {
        log.debug("httpPostSuccess: " + event.memo.message);
        switch (event.memo.resource.name) {
            case 'tags_json':
                mtwilson.atag.notify({text: i18n.t("notify.create_tag_success"),clearAfter: 'AUTO', status: 'INFO'});
                event.memo.resource.app.input.merge({name: '', value: ''});
                tag_create_form_removeValue();
                mtwilson.atag.searchTags('tag-search-form');
                break;
            case 'rdfTriples':
                mtwilson.atag.notify({text: i18n.t("notify.create_rdf_triple_success"),clearAfter: 'AUTO', status: 'INFO'});
                event.memo.resource.app.input.merge({subject: '', predicate: '', object: ''});
                break;
            case 'selections_json':
                console.log("------------ In the selections case -----------");
                console.log(event.memo.message);
                mtwilson.atag.notify({text: i18n.t("notify.create_selection_success"),clearAfter: 'AUTO', status: 'INFO'});
                event.memo.resource.app.input.merge({name: '', subjects: [], tags: []});
                var i = pres_selections.input.selection.length;
                console.log(i);
                while (i--) {
                    attr_object = {selection_name: event.memo.response.name, kv_attribute_id: pres_selections.input.selection[i].tag.id};
                    ajax.json.post('selection_kv_attributes', attr_object, {app: pres_selections});
                    console.log(attr_object);
                }
                selection_create_form_removeAllValues();
		loadSelsCall = true;
                mtwilson.atag.searchSelections('selection-search-form');
                break;
            case 'certificateRequests':
                if(event.memo.resource.func == 'bulk_provisioning') {
                    updateHostProvisioningStatus(event.memo.resource.app, 'Tag Certificate Created. Certificate being deployed');

                    var provisionObject = {
                            certificate_id: jQuery(event.memo.response).find('id')[0].innerHTML,
                            host: event.memo.resource.app
                    };
                    ajax.json.post('provision-certificate', provisionObject,
                    {
                        'uri': '/mtwilson-portal/v2proxy/rpc/deploy-tag-certificate',
                        'datapath': null,
                        'func': 'bulk_provisioning'
                    });

                    break;
                }
                mtwilson.atag.notify({text: i18n.t("notify.create_certificate_request_success"),clearAfter: 'AUTO', status: 'INFO'});
                event.memo.resource.app.input.merge({subject: ''});
                
                log.debug("automatically setting current time for follow-up search");
                log.debug("timedelta is "+ajax.timeDelta);
                $('certificate-search-valid').value = Date.parse('now').addMilliseconds(ajax.timeDelta).toISOString();
                
                mtwilson.atag.searchCertificates($('searchCertButton'))
                break;
            case 'certificates':
                mtwilson.atag.notify({text: i18n.t("notify.create_certificate_success"),clearAfter: 'AUTO', status: 'INFO'});
                break;
            case 'provision-certificate':
                if(event.memo.resource.func == 'bulk_provisioning') {
                    updateHostProvisioningStatus(event.memo.content.host, 'Deployed successfully');
                    break;
                }
                mtwilson.atag.notify({text: i18n.t("notify.provision_certificate_success"),clearAfter: 'AUTO', status: 'INFO'});
                $('certificate-provision-host').clear();
                $('certificate-provision-form').hide();
                break;
            case 'deploy-certificate':
                mtwilson.atag.notify({text: i18n.t("notify.deploy_certificate_success"),clearAfter: 'AUTO', status: 'INFO'});
                break;
            case 'revoke-certificate':
                mtwilson.atag.notify({text: "notify.revoke_certificate_success", clearAfter: 'AUTO', status: 'INFO'});
                break;
            case 'configurations':
                mtwilson.atag.notify({text: i18n.t("notify.create_configuration_success"),clearAfter: 'AUTO', status: 'INFO'});
                break;
            case 'files':
                mtwilson.atag.notify({text: i18n.t("notify.create_file_success"),clearAfter: 'AUTO', status: 'INFO'});
                break;
            default:
                log.debug("No handler for successful HTTP POST of " + event.memo.resource.name);
                break;
        }
        ;
        /*
         if( event.memo.resource.name === 'tags' ) {
         //$('tag-create-form').reset();
         // reset the form's data model, and rivets will automatically update the form GUI. 
         // you CANNOT just set forms['tag-create-form'] = { name:'', oid:'', values:[] } because that will 
         // replace the reference and will cause rivets to lose the connection between the model & the form.
         //            event.memo.resource.app.input.name = ''; //mtwilson.rivets.forms['tag-create-form'].name = ''; 
         //            event.memo.resource.app.input.oid = '';//mtwilson.rivets.forms['tag-create-form'].oid = ''; 
         //            event.memo.resource.app.input.values = [];//mtwilson.rivets.forms['tag-create-form'].values = []; 
         //            event.memo.resource.app.validator.reset();
         //            $('tag-create-name').value = '';
         //            $('tag-create-oid').value = '';
         //            $('tag-create-values').value = '';
         }
         */
        //i18nInit();
    });
    
    document.observe("ajax:httpPostFailure", function(event) {
        log.debug("httpPostFailure: " + event.memo.message);
        var link = "";
        if( event.memo.unauthorized ) { link = " <a href='../login.htm' target='_top'>login</a>"; }
        switch (event.memo.resource.name) {
            case 'tags_json':
                mtwilson.atag.notify({text: i18n.t("notify.create_tag_failure") + ': ' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
            case 'rdfTriples':
                mtwilson.atag.notify({text: i18n.t("notify.create_rdf_triple_failure") + ': ' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
            case 'selections_json':
                mtwilson.atag.notify({text: i18n.t("notify.create_selection_failure") + ': ' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
            case 'certificateRequests':
                if(event.memo.resource.func == 'bulk_provisioning') {
                    updateHostProvisioningStatus(event.memo.resource.app, 'Failed');
                    break;
                }
                mtwilson.atag.notify({text: i18n.t("notify.create_certificate_request_failure") + ': ' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
            case 'certificates':
                mtwilson.atag.notify({text: i18n.t("notify.create_certificate_failure") + ': ' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
            case 'provision-certificate':
                if(event.memo.resource.func == 'bulk_provisioning') {
                    updateHostProvisioningStatus(event.memo.resource.app, 'Failed');
                    break;
                }
                mtwilson.atag.notify({text: i18n.t("notify.provision_certificate_failure") + ': ' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
            case 'deploy-certificate':
                mtwilson.atag.notify({text: i18n.t("notify.deploy_certificate_failure") + ': ' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
            case 'revoke-certificate':
                mtwilson.atag.notify({text: i18n.t("notify.revoke_certificate_failure") + ': ' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
            case 'configurations':
                mtwilson.atag.notify({text: i18n.t("notify.create_configuration_failure") + ': ' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
            case 'files':
                mtwilson.atag.notify({text: i18n.t("notify.create_file_failure") + ': ' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
            default:
                log.debug("No handler for failure HTTP POST of " + event.memo.resource.name);
                mtwilson.atag.notify({text: i18n.t("notify.failure") + ': ' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
        }
        ;
        //i18nInit();
    });

    document.observe("ajax:httpDeleteSuccess", function(event) {
        log.debug("httpDeleteSuccess: " + event.memo.message);
        switch (event.memo.resource.name) {
            case 'tags':
                mtwilson.atag.notify({text: i18n.t("notify.delete_tag_success"), clearAfter: 'AUTO', status: 'INFO'});
                var i;
                for (i = data.tags.length - 1; i >= 0; i--) {
                    if (('id' in data.tags[i]) && data.tags[i].id == event.memo.content.id) {
                        data.tags.splice(i, 1); 
                    }
                }
                //view.sync();
                mtwilson.rivets.views['tag-browse-table'].sync();
                mtwilson.atag.searchTags('tag-search-form');
                event.memo.resource.app.input.merge({name: '', oid: '', values: []});
                break;
            case 'rdfTriples':
                mtwilson.atag.notify({text: i18n.t("notify.delete_rdf_triple_success"), clearAfter: 'AUTO', status: 'INFO'});
                log.debug("delete rdf triples after notify: "+event.memo.content.uuid);
                var i;
                for (i = data.rdfTriples.length - 1; i >= 0; i--) {
                    if (('uuid' in data.rdfTriples[i]) && data.rdfTriples[i].uuid == event.memo.content.uuid) {
                        data.rdfTriples.splice(i, 1);
                    }
                }
        //        view.sync();
                mtwilson.rivets.views['rdf-triple-browse-table'].sync();
                event.memo.resource.app.input.merge({subject: '', predicate: '', object: ''});
                break;
            case 'selections':
//                log.debug("deleted selection notification...");
                mtwilson.atag.notify({text: i18n.t("notify.delete_selection_success"), clearAfter: 'AUTO', status: 'INFO'});
                log.debug("deleted selection input merge...");
                var i;
                for (i = data.selections.length - 1; i >= 0; i--) {
                    if (data.selections[i].id == event.memo.content.id) {
                        data.selections.splice(i, 1);  // maybe this should move to the httpDeleteSuccess event listener? 
                    }
                }
        //        view.sync();
                mtwilson.rivets.views['selection-browse-table'].sync();
                mtwilson.atag.searchSelections('selection-search-form');
                event.memo.resource.app.input.merge({name: '', subjects: [], tags: []});
                break;
            case 'certificateRequests':
                mtwilson.atag.notify({text: i18n.t("notify.delete_certificate_request_success"), clearAfter: 'AUTO', status: 'INFO'});
                log.debug("delete certificate requests after notify: "+event.memo.content.uuid);
                var i;
                for (i = data.certificateRequests.length - 1; i >= 0; i--) {
                    if (('uuid' in data.certificateRequests[i]) && data.certificateRequests[i].uuid == event.memo.content.uuid) {
                        data.certificateRequests.splice(i, 1);  // maybe this should move to the httpDeleteSuccess event listener? 
                        //					return;
                    }
                }
                //view.sync();
                mtwilson.rivets.views['certificate-request-browse-table'].sync();
                event.memo.resource.app.input.merge({subject: '', tags: []});
                mtwilson.atag.searchCertificates($('searchCertButton'))
                break;
            case 'certificates':
                mtwilson.atag.notify({text: i18n.t("notify.delete_certificate_success"), clearAfter: 'AUTO', status: 'INFO'});
                log.debug("delete certificates after notify: "+event.memo.content.id);
                var i;
                for (i = data.certificates.length - 1; i >= 0; i--) {
                    if (('id' in data.certificates[i]) && data.certificates[i].id == event.memo.content.id) {
                        data.certificates.splice(i, 1);
                    }
                }
                //view.sync();
                mtwilson.rivets.views['certificate-browse-table'].sync();
                break;
            case 'configurations':
                mtwilson.atag.notify({text: i18n.t("notify.delete_configuration_success"), clearAfter: 'AUTO', status: 'INFO'});
//                    event.memo.resource.app.input.merge({name:'', subjects:[], tags:[]});
                break;
            case 'files':
                mtwilson.atag.notify({text: i18n.t("notify.delete_file_success"), clearAfter: 'AUTO', status: 'INFO'});
//                    event.memo.resource.app.input.merge({name:'', subjects:[], tags:[]});
                break;
            default:
                log.debug("No handler for successful HTTP DELETE of " + event.memo.resource.name);
                break;
        }
        ;
        //i18nInit();
    });
    
    document.observe("ajax:httpDeleteFailure", function(event) {
        log.debug("httpDeleteFailure: " + event.memo.message);
        var link = "";
        if( event.memo.unauthorized ) { link = " <a href='../login.htm' target='_top'>login</a>"; }
        switch (event.memo.resource.name) {
            case 'tags':
                mtwilson.atag.notify({text: i18n.t("notify.delete_tag_failure") + ': ' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
            case 'rdfTriples':
                mtwilson.atag.notify({text: i18n.t("notify.delete_rdf_triple_failure") + ': ' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
            case 'selections':
                mtwilson.atag.notify({text: i18n.t("notify.delete_selection_failure") + ': ' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
            case 'certificateRequests':
                mtwilson.atag.notify({text: i18n.t("notify.delete_certificate_request_failure") + ': ' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
            case 'certificates':
                mtwilson.atag.notify({text: i18n.t("notify.delete_certificate_failure") + ': ' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
            case 'configurations':
                mtwilson.atag.notify({text: i18n.t("notify.delete_configuration_failure") + ': ' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
            case 'files':
                mtwilson.atag.notify({text: i18n.t("notify.delete_file_failure") + ': ' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
            default:
                log.debug("No handler for failure HTTP DELETE of " + event.memo.resource.name);
                mtwilson.atag.notify({text: i18n.t("notify.failure") + ': ' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
        }
        ;
        //i18nInit();
    });

    document.observe("ajax:httpPutSuccess", function(event) {
        log.debug("httpPutSuccess: " + event.memo.message);
        switch (event.memo.resource.name) {
            case 'tags':
                mtwilson.atag.notify({text: i18n.t("notify.update_tag_success"), clearAfter: 'AUTO', status: 'INFO'});
                tag_create_form_removeValue();
                mtwilson.atag.searchTags('tag-search-form');
                event.memo.resource.app.input.merge({name: '', oid: '', values: []});
                break;
            case 'rdfTriples':
                mtwilson.atag.notify({text: i18n.t("notify.update_rdf_triple_success"), clearAfter: 'AUTO', status: 'INFO'});
                event.memo.resource.app.input.merge({subject: '', predicate: '', object: ''});
                break;
            case 'selections':
                mtwilson.atag.notify({text: i18n.t("notify.update_selection_success"), clearAfter: 'AUTO', status: 'INFO'});
                event.memo.resource.app.input.merge({name: '', subjects: [], tags: []});
                break;
            case 'certificateRequests':
                mtwilson.atag.notify({text: i18n.t("notify.update_certificate_request_success"), clearAfter: 'AUTO', status: 'INFO'});
                event.memo.resource.app.input.merge({subject: '', tags: []});
                break;
            case 'certificates':
                mtwilson.atag.notify({text: i18n.t("notify.update_certificate_success"), clearAfter: 'AUTO', status: 'INFO'});
                break;
            case 'configurations':
                mtwilson.atag.notify({text: i18n.t("notify.update_configuration_success"), clearAfter: 'AUTO', status: 'INFO'});
//                    event.memo.resource.app.input.merge({name:'', subjects:[], tags:[]});
                break;
            case 'files':
                mtwilson.atag.notify({text: i18n.t("notify.update_file_success"), clearAfter: 'AUTO', status: 'INFO'});
//                    event.memo.resource.app.input.merge({name:'', subjects:[], tags:[]});
                break;
            default:
                log.debug("No handler for successful HTTP PUT of " + event.memo.resource.name);
                break;
        }
        ;
        //i18nInit();
    });
    
    document.observe("ajax:httpPutFailure", function(event) {
        log.debug("httpPutFailure: " + event.memo.message);
        var link = "";
        if( event.memo.unauthorized ) { link = " <a href='../login.htm' target='_top'>login</a>"; }
        switch (event.memo.resource.name) {
            case 'tags':
                mtwilson.atag.notify({text: i18n.t("notify.update_tag_failure") + ': ' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
            case 'rdfTriples':
                mtwilson.atag.notify({text: i18n.t("notify.update_rdf_triple_failure") + ': ' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
            case 'selections':
                mtwilson.atag.notify({text: i18n.t("notify.update_selection_failure") + ': ' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
            case 'certificateRequests':
                mtwilson.atag.notify({text: i18n.t("notify.update_certificate_request_failure") + ': ' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
            case 'certificates':
                mtwilson.atag.notify({text: i18n.t("notify.update_certificate_failure") + ': ' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
            case 'configurations':
                mtwilson.atag.notify({text: i18n.t("notify.update_configuration_failure") + ':' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
            case 'files':
                mtwilson.atag.notify({text: i18n.t("notify.update_file_failure") + ': ' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
            default:
                log.debug("No handler for failure HTTP PUT of " + event.memo.resource.name);
                mtwilson.atag.notify({text: i18n.t("notify.failure") + ': ' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
        }
        ;
        //i18nInit();
    });

    document.observe("ajax:httpGetSuccess", function(event) {
        log.debug("httpGetSuccess: " + event.memo.message);
        //log.debug("HTTP GET OK: " + event.memo.resource.name);
        switch (event.memo.resource.name) {
            case 'resources':
                log.debug("resources: " + Object.toJSON(ajax.data.getx("event.memo.resource.datapath")));
//                mtwilson.atag.notify({text: i18n.t("notify.retrieve_resources_success"), clearAfter: 'AUTO', status: 'INFO'});
                mtwilson.atag.notify({text: "notify.retrieve_resources_success", clearAfter: 'AUTO', status: 'INFO'});
                break;
            case 'tags':
                // update various controls that refer to the tags... 
                selection_create_form_init();  
                $('tag-search-form').hide();

                if (event.memo.response.length > 0) {
                    mtwilson.atag.notify({text: event.memo.response.length + ' ' + i18n.t("notify.retrieve_tags_success"), clearAfter: 'AUTO', status: 'INFO'});
                } else {
                    mtwilson.atag.notify({text: i18n.t("notify.retrieve_tags_warning"), clearAfter: 'CONFIRM', status: 'WARN'});
                }
                break;
            case 'unfiltered_tags':
                // Re-arrange the object
                selection_create_form_init();
                var iter = 0;
                data.rearranged_tags[iter] = {};
                data.rearranged_tags[iter].name = 'Select';
                data.rearranged_tags[iter].text = i18n.t("select.select");
                data.rearranged_tags[iter].tagValues = [];
                iter++;
                for (var i = 0; i < data.unfiltered_tags.length; i++) {
                    // Workaround: find the locaiton of the hash with the same name
                    var loop_obj = data.unfiltered_tags[i];
                    var el_added = false;
                    for(var loop = 0; loop < data.rearranged_tags.length; loop++) {
                        if(data.rearranged_tags[loop].name == loop_obj.name) {
                            data.rearranged_tags[loop].tagValues.push({id: loop_obj.id, value: loop_obj.value})
                            el_added = true;
                        }
                    }
                    if(!el_added) {
                        data.rearranged_tags[iter] = {};
                        data.rearranged_tags[iter].name = loop_obj.name;
                        data.rearranged_tags[iter].text = loop_obj.name;
                        data.rearranged_tags[iter].tagValues = [{id: loop_obj.id, value: loop_obj.value}];
                        iter++;
                    }
                }
                //console.log(data.rearranged_tags);
                //data.rearranged_tags = [{name: 'select', tagValues: []}, {name: 'state', tagValues: [{uui: '123', value: 'CA'}]}, {name: 'country', tagValues: [{id: '123', value: 'US'}]}];
                break;
            case 'rdfTriples':
                mtwilson.atag.notify({text: i18n.t("notify.retrieve_rdf_triples_success"), clearAfter: 'AUTO', status: 'INFO'});
                break;
            case 'selections':
                //log.debug("got selections! "+Object.toJSON(event.memo));
//                    automatic-tag-selection-name
                if (event.memo.response.length > 0) {
                    mtwilson.atag.notify({text: event.memo.response.length + ' ' + i18n.t("notify.retrieve_selections_success"), clearAfter: 'AUTO', status: 'INFO'});
                } else {
                    mtwilson.atag.notify({text: i18n.t("notify.retrieve_selections_warning"), clearAfter: 'CONFIRM', status: 'WARN'});
                }
		$('selection-search-form').hide();
                break;
          case 'certificates_json':
              console.log("Waiting4Host2PopulateCerts httpSuccess");
              wait4Hosts2PopulateCerts();

		/*if(data.certificates != null && data.hosts != null) {
                        for(cert_loop = 0; cert_loop < data.certificates.length; cert_loop++) {
                                for(host_loop = 0; host_loop < data.hosts.length; host_loop++) {
                                        if(data.certificates[cert_loop].subject == data.hosts[host_loop].hardware_uuid) {
                                                data.certificates[cert_loop].subjectName = data.hosts[host_loop].name;
                                                continue;
                                        }
                                }
                        }
                }*/

                console.log("Data Length: " + data.certificates.length);
                log.debug("after certificates_json ws.data: "+Object.toJSON(ws.data));
                
                
                for(var loop = 0; loop < data.certificates.length; loop++) {
                    console.log("Certificates Object: "+Object.toJSON(data.certificates[loop]));
                    
                    ////////////////////////////
//                        for(host_loop = 0; host_loop < data.hosts.length; host_loop++) {
//                                if(data.certificates[cert_loop].subject == data.hosts[host_loop].hardware_uuid) {
//                                        data.certificates[cert_loop].subjectName = data.hosts[host_loop].name;
//                                        isNameSet = true;
//                                        continue;
//                                }
//                        }
                    //////////////////////////////////
                        data.certificates[loop].status = "Active";
                        var now = new Date(event.memo.serverTime);
                        if(JSON.parse(data.certificates[loop].revoked)) {
                                data.certificates[loop].status = "Revoked";
                        } else if(!now.between(new Date(data.certificates[loop].notBefore), new Date(data.certificates[loop].notAfter))) {
                                data.certificates[loop].status = 'Expired';
                        }
                }
                populateCertsInfoToTable(data.certificates);
                view.sync();
                break;
            case 'certificateRequests':
                if (event.memo.response.length > 0) {
                    mtwilson.atag.notify({text: event.memo.response.length + ' ' + i18n.t("notify.retrieve_certificate_requests_success"), clearAfter: 'AUTO', status: 'INFO'});
                } else {
                    mtwilson.atag.notify({text: i18n.t("notify.retrieve_certificate_requests_warning"), clearAfter: 'CONFIRM', status: 'WARN'});
                }
                break;
            case 'certificates':
                if (event.memo.response.length > 0) {
                    mtwilson.atag.notify({text: event.memo.response.length + ' ' + i18n.t("notify.retrieve_certificates_success"), clearAfter: 'AUTO', status: 'INFO'});
                } else {
                    mtwilson.atag.notify({text: i18n.t("notify.retrieve_certificates_warning"), clearAfter: 'CONFIRM', status: 'WARN'});
                }
		$('certificate-search-form').hide();
                break;
            case 'configurations':
                if (event.memo.resource.callback) {
                    event.memo.resource.callback(event.memo);
                }
                if (event.memo.response.length > 0) {
                    mtwilson.atag.notify({text: event.memo.response.length + ' ' + i18n.t("notify.retrieve_configurations_success"), clearAfter: 'AUTO', status: 'INFO'});
                } else {
                    mtwilson.atag.notify({text: i18n.t("notify.retrieve_configurations_warning"), clearAfter: 'CONFIRM', status: 'WARN'});
                }
                break;
            case 'files':
                if (event.memo.resource.callback) {
                    event.memo.resource.callback(event.memo);
                }
                mtwilson.atag.notify({text: i18n.t("notify.retrieve_file_success"), clearAfter: 'AUTO', status: 'INFO'});
                break;
            case 'selection_kv_attributes':
                var tmp_dictionary = {};
                var loop = 0;
                $('selection-search-form').hide();
                if(disable_sel_render) {
                        disable_sel_render = false;
                        break;
                }
                selectedSelectionXML = '';
                data.selections.clear();
                for (var i = 0; i < data.selection_details.length; i++) {
                        if(tmp_dictionary[data.selection_details[i].selection_id] == null) {
                                data.selections[loop] = {};
                                data.selections[loop].id = data.selection_details[i].selection_id;
                                data.selections[loop].name = data.selection_details[i].selection_name;
                                data.selections[loop].description= data.selection_details[i].selection_description;
                                loop++;
                                tmp_dictionary[data.selection_details[i].selection_id] = true;
                        }
                }
                data.selection_details = [];
                break;
            case 'hosts':
                wait4Hosts2PopulateCerts();
                if(document.URL.indexOf('tab=certificates') > -1) {
                        break;
                }

                /*if(data.certificates != null && data.hosts != null) {
                        for(cert_loop = 0; cert_loop < data.certificates.length; cert_loop++) {
                                for(host_loop = 0; host_loop < data.hosts.length; host_loop++) {
                                        if(data.certificates[cert_loop].subject == data.hosts[host_loop].hardware_uuid) {
                                                data.certificates[cert_loop].subjectName = data.hosts[host_loop].name;
                                                continue;
                                        }
                                }
                        }
                        view.sync();
                }*/


                for(var i = data.hosts.length-1; i >= 0; i--) {
		    if(data.hosts[i].connection_url != undefined && data.hosts[i].connection_url.indexOf('vmware') != -1) {
                        data.hosts.splice(i, 1);
                    }
                }
                ajax.view.sync();

                jQuery('#my-select').multiSelect({'dblClick': true, 'selectionFooter': '<div class="custom-header" data-i18n="label.servers_to_provision">Servers to provision</div>', 'selectableFooter': '<div class="custom-header" data-i18n="label.available_servers">Available servers</div>',
                        afterSelect: function(value){
                                addElement2SelectedHosts(value[0]);
                        },
                        afterDeselect: function(value){
                                removeElement2SelectedHosts(value[0]);
                        }});
                break;
            case 'uuid':
                
                //$('certificate-request-create-subject').value = event.memo.response.host_uuid;
                mtwilson.rivets.forms["certificate-request-create-form"].input.subject  = event.memo.response.host_uuid;
                mtwilson.rivets.views["certificate-request-create-form"].sync();
                $('certificate-request-create-subject').focus();

                //alert("UUID of requested system is " + event.memo.response.host_uuid);
            default:
                log.debug("No handler for successful HTTP GET of " + event.memo.resource.name);
                break;
        }
        ;
        //i18nInit();
    });
    
    document.observe("ajax:httpGetFailure", function(event) {
        log.debug("httpGetFailure: " + event.memo.message);
        //log.debug("HTTP GET OK: " + event.memo.resource.name);
        var link = "";
        if( event.memo.unauthorized ) { link = " <a href='../login.htm' target='_top'>login</a>"; }
        switch (event.memo.resource.name) {
            case 'resources':
                //mtwilson.atag.notify({text: i18n.t("notify.retrieve_resources_failure") + ': ' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
            case 'tags':
                mtwilson.atag.notify({text: i18n.t("notify.retrieve_tags_failure") + ': ' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
            case 'rdfTriples':
                mtwilson.atag.notify({text: i18n.t("notify.retrieve_rdf_triples_failure") + ': ' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
            case 'selections':
                mtwilson.atag.notify({text: i18n.t("notify.retrieve_selections_failure") + ': ' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
            case 'certificateRequests':
                mtwilson.atag.notify({text: i18n.t("notify.retrieve_certificate_requests_failure") + ': ' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
            case 'certificates':
                mtwilson.atag.notify({text: i18n.t("notify.retrieve_certificates_failure"), clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
            case 'configurations':
                mtwilson.atag.notify({text: i18n.t("notify.retrieve_configurations_failure") + ': ' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
            case 'files':
                mtwilson.atag.notify({text: i18n.t("notify.retrieve_file_failure") + ': ' + event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
            case 'uuid':
                mtwilson.atag.notify({text: i18n.t("notify.retrieve_uuid_failure") + ' '+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                //alert("getUUID:" + event.memo.response);
            default:
                log.debug("No handler for failure HTTP GET of " + event.memo.resource.name);
                mtwilson.atag.notify({text: i18n.t("notify.failure") + ': '+event.memo.message+link, clearAfter: 'CONFIRM', status: 'ERROR'});
                break;
        }
        ;
        //i18nInit();
    });

    mtwilson.atag.createTag = function(input) {
        if($('tag-create-name').value.strip() == '' || $('tag-create-values').value.strip() == '') { return }
        var report = validate(input);
        if (report.isValid) {
            var tagObject = report.input.clone(); // or use report.input.cloneJSON() if it has circular references (it shouldn't!) or another way is Object.toJSON(report.input).evalJSON(); 
            if($('tag-create-id').value != '') {
                tagObject.id = $('tag-create-id').value;
            }

            if(tagObject.id != undefined) {
                ajax.json.put('tags', tagObject, {}); // pass {app:report} so it will be passed to the event handler after the request is complete
            } else {
                ajax.json.post('tags_json', tagObject, {app: report}); // pass {app:report} so it will be passed to the event handler after the request is complete
            }
            $('tag-create-name').clear();
            $('tag-create-values').clear();
            $('tag-create-name').focus();
        }
    };

    mtwilson.atag.createCertificateRequest = function(input) {
        var report = validate(input); // subject and selection
        subject_id = $F("uuid-populate-host");
        selection_id = getSelectOptionValue($('certificate-request-create-tag-selection'));
        if (report.isValid) {
            if( true ) {
                var requestObject = "";
                console.log("Certificate request: " + Object.toJSON(requestObject));

                // Get the Selection details
                xmlhttp=new XMLHttpRequest();
                xmlhttp.onreadystatechange=function() {
                    if (xmlhttp.readyState==4 && xmlhttp.status==200) {
                        var requestObject = xmlhttp.responseText;
                        //requestObject is a message/rfc822 formatted string containing an encrypted selection like {"selections":[{"attributes":[{"text":{"value":"city=Folsom"},"oid":"2.5.4.789.1"},{"text":{"value":"state=CA"},"oid":"2.5.4.789.1"},{"text":{"value":"city=Santa Clara"},"oid":"2.5.4.789.1"}]}]}
                        ajax.custom.post('certificateRequests', requestObject, {app: report, contentType: 'message/rfc822', accept: 'application/pkix-cert'}, {subject: subject_id}); // pass {app:report} so it will be passed to the event handler after the request is complete
                    }
                };
                xmlhttp.open("GET","/mtwilson-portal/v2proxy/tag-selections/" + selection_id+".enc",true);
                xmlhttp.setRequestHeader("Accept", "message/rfc822"); // indicates we want the encrypted xml, which is currently delivered as a message/rfc822 document
                xmlhttp.send();
            }
            else {
                var requestObject = "";
                console.log("Certificate request: " + Object.toJSON(requestObject));

                // Get the Selection details
                xmlhttp=new XMLHttpRequest();
                xmlhttp.onreadystatechange=function() {
                    if (xmlhttp.readyState==4 && xmlhttp.status==200) {
                        var requestObject = xmlhttp.responseText.evalJSON();
                        //requestObject looks like {"selections":[{"attributes":[{"text":{"value":"city=Folsom"},"oid":"2.5.4.789.1"},{"text":{"value":"state=CA"},"oid":"2.5.4.789.1"},{"text":{"value":"city=Santa Clara"},"oid":"2.5.4.789.1"}]}]}
                        ajax.json.post('certificateRequests', requestObject, {app: report}, {subject: subject_id}); // pass {app:report} so it will be passed to the event handler after the request is complete
                    }
                };
                xmlhttp.open("GET","/mtwilson-portal/v2proxy/tag-selections/" + selection_id + ".json",true);
                xmlhttp.send();            
            } // if report.isvalid
        
//	    requestObject = {"selections":[{"attributes":[{"text":{"value":"city=Folsom"},"oid":"2.5.4.789.1"},{"text":{"value":"state=CA"},"oid":"2.5.4.789.1"},{"text":{"value":"city=Santa Clara"},"oid":"2.5.4.789.1"}]}]}
        }
    };
    
    mtwilson.atag.autoPopulateUUID = function(input) {
        //$('certificate-request-create-subject').value = "Some Random UUID";
        //alert("its working");
        var ip = $('uuid-populate-host').value;
        ajax.json.get('uuid', {'ipaddress':ip});      
    };

    mtwilson.atag.createSelection = function(input) {
        log.debug("the form model is: " + Object.toJSON(mtwilson.rivets.forms['selection-create-form'].input));
        var report = validate(input);
        if (report.isValid) {
            log.debug("report input: " + Object.toJSON(report.input));
            // sample post format: {"name":"default","tags":[{"tagName":"state","tagOid":"1.1.1.1","tagValue":"CA"},{"tagName":"city","tagOid":"2.2.2.2","tagValue":"sacramento"}]}
            // when creating selections its the "selection" array of the form data that we submit to the server, together with the name of the selection:
            var selectionObject = {name: $F('selection-create-name'), description: $F('selection-create-desc')}; // should use report.input.name but it's not being populated 
            /*var i = report.input.selection.length; // but for tags we need to submit just the uuid & value... not the whole tag
            while (i--) {
                selectionObject.tags.push({tagName: report.input.selection[i].tag.name, tagValue: report.input.selection[i].value});
            }*/
            log.debug("Posting selection: {}", Object.toJSON(selectionObject));
            ajax.json.post('selections_json', selectionObject, {app: report}); // pass {app:report} so it will be passed to the event handler after the request is complete
            pres_selections = validate(input);
        }
    };

    mtwilson.atag.createRdfTriple = function(input) {
        var report = validate(input);
        if (report.isValid) {
            var rdfTripleObject = report.input.clone(); //Object.toJSON(report.input).evalJSON();
            ajax.json.post('rdfTriples', [rdfTripleObject], {app: report});
//            view.sync(); //view.update(data);
        }
    };

    // removes all tags with this uuid
    mtwilson.atag.removeRdfTriple = function(uuid) {
        var i;
        for (i = data.rdfTriples.length - 1; i >= 0; i--) {
            if (('uuid' in data.rdfTriples[i]) && data.rdfTriples[i].uuid == uuid) {
                ajax.json.delete('rdfTriples', data.rdfTriples[i]);
                //data.rdfTriples.splice(i, 1);  // maybe this should move to the httpDeleteSuccess event listener? 
                //					return;
            }
            //view.sync(); //view.update(data);
        }
//        view.sync();
        //mtwilson.rivets.views['rdf-triple-browse-table'].sync();

        /*
         for(var i=sampledata.rdfTriples.length-1; i>=0; i--) {
         if( ('uuid' in sampledata.rdfTriples[i]) && sampledata.rdfTriples[i].uuid == uuid ) {
         sampledata.rdfTriples.splice(i,1);  // removes just this element...  note it's the first one found, so if you search for something that appears many times, only the first one will be removed!
         //					return;
         }				
         rdfview.update(sampledata);
         }*/
    };


    /*
    mtwilson.atag.removeFirstTag = function(oid) {
        var i;
        for (i = 0; i < data.tags.length; i--) {
            if (('oid' in data.tags[i]) && data.tags[i].oid == oid) {
                ajax.json.delete('tags', data.tags[i]);
                data.tags.splice(i, 1);  // removes just this element...  note it's the first one found, so if you search for something that appears many times, only the first one will be removed!
                view.sync(); //view.update(data);
                return;
            }
        }
    };
    */

    // removes all tags with this oid
    mtwilson.atag.removeTag = function(uuid) {
        var i;
        for (i = data.tags.length - 1; i >= 0; i--) {
            if (('id' in data.tags[i]) && data.tags[i].id == uuid) {
                ajax.json.delete('tags', data.tags[i]);
                //data.tags.splice(i, 1);  // maybe this should move to the httpDeleteSuccess event listener? 
                //					return;
            }
        }
        //view.sync();
        //mtwilson.rivets.views['tag-browse-table'].sync();
    };

    // Get the selection details
    mtwilson.atag.getSelectionDetails = function(uuid) {
    data.selection_details = [];
    ajax.json.get('selection_kv_attributes', {'id':uuid});      
    $('table_view_sel_details').show();
    $('tableDisplayScroll_small').hide();
    }
    // removes all tags with this oid
    mtwilson.atag.removeSelection = function(uuid) {
        log.debug("removeSelection: " + uuid);
        var i;
        for (i = data.selections.length - 1; i >= 0; i--) {
      //      log.debug("removeSelection from model; looking at index " + i);
    //        log.debug("index i is: " + Object.toJSON(data.selections[i]));
  //          log.debug("index i uuid is: " + data.selections[i].uuid);
//            log.debug("typeof data.selections[i].uuid = " + (typeof data.selections[i].uuid));
            if (data.selections[i].id == uuid) {
                log.debug("found selection with uuid " + data.selections[i].uuid);
                ajax.json.delete('selections', data.selections[i]);
        
    //            log.debug("ajax request ok");
      //          data.selections.splice(i, 1);  // maybe this should move to the httpDeleteSuccess event listener? 
  //              log.debug("model splice ok");
                //					return;
            }
        }
//        log.debug("removeSelection synchrnoizing view...");
//        view.sync();
 //       mtwilson.rivets.views['selection-browse-table'].sync();

    };
     // removes all tags with this oid
    mtwilson.atag.exportXmlSelection = function(uuid, type) {
        log.debug("exportXmlSelection: " + uuid);
        var url = "/mtwilson-portal/v2proxy/tag-selections/" + uuid + "." + type;
        window.open(url,'open_window' , 'menubar, toolbar, location, directories, status, scrollbars, resizable, dependent, width=640, height=480, left=0, top=0');
    };
    
    
    mtwilson.atag.removeCertificateRequest = function(uuid) {
        var i;
        for (i = data.certificateRequests.length - 1; i >= 0; i--) {
            if (('uuid' in data.certificateRequests[i]) && data.certificateRequests[i].uuid == uuid) {
                ajax.json.delete('certificateRequests', data.certificateRequests[i]);
                //data.certificateRequests.splice(i, 1);  // maybe this should move to the httpDeleteSuccess event listener? 
                //					return;
            }
        }
        //view.sync();
        //mtwilson.rivets.views['certificate-request-browse-table'].sync();
    };



    mtwilson.atag.deleteCertificate = function(uuid) {
        var i;
        for (i = data.certificates.length - 1; i >= 0; i--) {
            if (('id' in data.certificates[i]) && data.certificates[i].id == uuid) {
                ajax.json.delete('certificates', data.certificates[i]);
                //data.certificates.splice(i, 1);  // maybe this should move to the httpDeleteSuccess event listener? 
                //					return;
            }
        }
        //view.sync();
        //mtwilson.rivets.views['certificate-browse-table'].sync();
    };
    

    mtwilson.atag.revokeCertificate = function(uuid) {
        var i;
        for (i = data.certificates.length - 1; i >= 0; i--) {
            if (('id' in data.certificates[i]) && data.certificates[i].id == uuid) {
                // optional argument:  "effective" date
                //ajax.json.post('certificates', data.certificates[i]); 
                log.debug("Sending provision-certificate request for "+ uuid);
                ajax.json.post('revoke-certificate', {'certId': uuid}, {'uri': '/AttestationService/resources/tag-certificate-requests-rpc/revoke-tag-certificate-api?certId='+uuid, datapath: 'revokeCertificates', idkey: 'uuid'});
            }
        }
        //view.sync();
//        mtwilson.rivets.views['certificate-browse-table'].sync();
    };
    mtwilson.atag.deployCertificate = function(uuid) {
        var i;
        for (i = data.certificates.length - 1; i >= 0; i--) {
            if (('id' in data.certificates[i]) && data.certificates[i].id == uuid) {
                // optional argument:  "effective" date
                //ajax.json.post('certificates', data.certificates[i]); 
                log.debug("Sending deploy-certificate request");
                ajax.json.post('deploy-certificate', {'certificate_id': uuid}, {'uri': '/mtwilson-portal/v2proxy/rpc/mtwilson-import-tag-certificate', datapath: 'deployCertificates', idkey: 'id'});
                //alert("Certificate deployed to Mt. Wilson");
            }
        }
        //view.sync();
//        mtwilson.rivets.views['certificate-browse-table'].sync();
    };


    mtwilson.atag.provisionCertificate = function(input) {
//        var report = validate(input);
//        if (report.isValid) {
        log.debug("provisionCertificate"); //  input: " + Object.toJSON(input));
//            log.debug("provisionCertificate  report: "+Object.toJSON(report));
//            var provisionObject = report.input.clone(); //Object.toJSON(report.input).evalJSON();
        var certificateUuid = $('certificate-provision-uuid').value; // provisionObject.certificateUuid;
        var provisionObject = {
            certificate_id: certificateUuid,
            host: $('certificate-provision-host').value
            //port: $('certificate-provision-port').value,
            //username: $('certificate-provision-username').value,
            //password: $('certificate-provision-password').value
        };
        log.debug("provisionCertificate  object: " + Object.toJSON(provisionObject)); // should have subject, host address, username, password
        //var certificateUuid = $('certificate-provision-uuid').value; // provisionObject.certificateUuid;
//            delete provisionObject['certificateUuid'];
        var wrappedProvisionObject = {'provision': provisionObject};
        //var pass = false;
        ajax.json.post('provision-certificate', provisionObject,
                {'uri': '/mtwilson-portal/v2proxy/rpc/deploy-tag-certificate',
                    'datapath': null // prevent result from being stored in global data model
                    /*'onSuccess': function(result) {
                        log.debug("provisionCertificate success! " + Object.toJSON(result));
                        $('certificate-provision-form').hide();
                        //pass = true;
                        ajax.event.fire("httpPostSuccess", {resource: {name: 'provision-certificate'}, content: wrappedProvisionObject, response: result.responseJSON});
                    },
                    'onFailure': function(result) {
                        log.error("provisionCertificate failed! " + Object.toJSON(result));
                        pass = false;
                    }*/
                }
        );
        //if( pass = true )
            //alert("Certificate provisioned to host");
        //else
            //alert("Unable to provision certificate to host");
//            view.sync(); //view.update(data);
//        }
    };

    mtwilson.atag.findTagByName = function(name) {
        var i;
        for (i = data.rearranged_tags.length - 1; i >= 0; i--) {
            if (('name' in data.rearranged_tags[i]) && data.rearranged_tags[i].name == name) {
                return data.rearranged_tags[i];
            }
        }
    };
    mtwilson.atag.findTagByUuid = function(uuid) {
        var i;
        for (i = data.unfiltered_tags.length - 1; i >= 0; i--) {
            if (('id' in data.unfiltered_tags[i]) && data.unfiltered_tags[i].id == uuid) {
                return data.unfiltered_tags[i];
            }
        }
    };
    mtwilson.atag.findTagByOid = function(oid) {
        var i;
        for (i = data.tags.length - 1; i >= 0; i--) {
            if (('oid' in data.tags[i]) && data.tags[i].oid == oid) {
                return data.tags[i];
            }
        }
    };


    mtwilson.atag.updateTags = function(tags) {
        data.tags = tags;
    };

    mtwilson.atag.searchTags = function(input) {
        var report = validate(input); 
//    if( report.isValid ) { ... }
        // each section of the tag search form looks like "Name [equalTo|contains] [argument]" so to create the search criteria
        // we form parameters like nameEqualTo=argument  or nameContains=argument
        var fields = ['name', 'oid', 'value'];
        var i;
        for (i = 0; i < fields.length; i++) {
            $('tag-search-' + fields[i]).name = fields[i] + $F('tag-search-' + fields[i] + '-criteria'); // this.options[this.selectedIndex].value;
        }

//	data.unfiltered_tags = data.tags;
        // first clear search results (otherwise the results we get from server will be appended to them)
        data.tags.clear();
//        ajax.json.get('tags', {uri:'/tags?' + $(report.formId).serialize()}); 
        ajax.json.get('tags_json', $(report.formId).serialize(true)); // pass parameters as object (serialize=true) and no other options (no third argument)
	if(loadTagsCall){
 	       ajax.json.get('unfiltered_tags', $(report.formId).serialize(true)); // pass parameters as object (serialize=true) and no other options (no third argument)
		loadTagsCall = false;
	}
//    apiwait("Searching tags...");
    };

    mtwilson.atag.searchRdfTriples = function(input) {
        var report = validate(input); 
//    if( report.isValid ) { ... }
        // each section of the tag search form looks like "Name [equalTo|contains] [argument]" so to create the search criteria
        // we form parameters like nameEqualTo=argument  or nameContains=argument
        var fields = ['subject', 'predicate', 'object'];
        var i;
        for (i = 0; i < fields.length; i++) {
            $('rdf-triple-search-' + fields[i]).name = fields[i] + $F('rdf-triple-search-' + fields[i] + '-criteria'); // this.options[this.selectedIndex].value;
        }

        // first clear search results (otherwise the results we get from server will be appended to them)
        data.rdfTriples.clear();
//        ajax.json.get('tags', {uri:'/tags?' + $(report.formId).serialize()});
        ajax.json.get('rdfTriples', $(report.formId).serialize(true)); // pass parameters as object (serialize=true) and no other options (no third argument)
//    apiwait("Searching tags...");
    };

    mtwilson.atag.searchSelections = function(input) {
        var report = validate(input); 
//    if( report.isValid ) { ... }
        // each section of the tag search form looks like "Name [equalTo|contains] [argument]" so to create the search criteria
        // we form parameters like nameEqualTo=argument  or nameContains=argument
        var fields = ['name', 'tagName', 'tagOid', 'tagValue'];
        var filterFields = ['name', 'attrName', 'tagOid', 'attrValue'];
        var i;
        for (i = 0; i < fields.length; i++) {
            $('selection-search-' + fields[i]).name = filterFields[i] + $F('selection-search-' + fields[i] + '-criteria'); // this.options[this.selectedIndex].value;
        }

        // first clear search results (otherwise the results we get from server will be appended to them)
        data.selection_details.clear();
//        ajax.json.get('tags', {uri:'/tags?' + $(report.formId).serialize()}); 
        ajax.json.get('selection_kv_attributes', $(report.formId).serialize(true)); // pass parameters as object (serialize=true) and no other options (no third argument)
//    apiwait("Searching tags...");
	if(loadSelsCall){
 	       ajax.json.get('unfiltered_sels', $(report.formId).serialize(true)); // pass parameters as object (serialize=true) and no other options (no third argument)
		loadSelsCall = false;
	}
    };


    mtwilson.atag.searchCertificateRequests = function(input) {
        var report = validate(input); 
//    if( report.isValid ) { ... }
        // each section of the tag search form looks like "Name [equalTo|contains] [argument]" so to create the search criteria
        // we form parameters like nameEqualTo=argument  or nameContains=argument
        var fields = ['subject', 'selection', 'status'];
        var i;
        for (i = 0; i < fields.length; i++) {
            $('certificate-request-search-' + fields[i]).name = fields[i] + $F('certificate-request-search-' + fields[i] + '-criteria'); // this.options[this.selectedIndex].value;
        }

        // first clear search results (otherwise the results we get from server will be appended to them)
        data.certificateRequests.clear();
//        ajax.json.get('tags', {uri:'/tags?' + $(report.formId).serialize()}); 
        ajax.json.get('certificateRequests', $(report.formId).serialize(true)); // pass parameters as object (serialize=true) and no other options (no third argument)
//    apiwait("Searching tags...");
    };

    mtwilson.atag.searchCertificates = function(input) {
        var report = validate(input); 
//    if( report.isValid ) { ... }
        // each section of the tag search form looks like "Name [equalTo|contains] [argument]" so to create the search criteria
        // we form parameters like nameEqualTo=argument  or nameContains=argument
        var fields = ['subject', 'issuer', 'valid', 'sha1', 'sha256', 'revoked'];
	if ($('certificate-search-valid').value.trim() == '') {
        	fields = ['subject', 'issuer', 'sha1', 'sha256', 'revoked'];
	}
        var i;
        for (i = 0; i < fields.length; i++) {
            if (document.getElementById('certificate-search-' + fields[i] + '-criteria')) {
                $('certificate-search-' + fields[i]).name = fields[i] + $F('certificate-search-' + fields[i] + '-criteria'); // this.options[this.selectedIndex].value;                
            }
            else {
                $('certificate-search-' + fields[i]).name = fields[i];
            }
        }

        // first clear search results (otherwise the results we get from server will be appended to them)
        data.certificates.clear();
//        ajax.json.get('tags', {uri:'/tags?' + $(report.formId).serialize()}); 
        ajax.json.get('certificates_json', $(report.formId).serialize(true)); // pass parameters as object (serialize=true) and no other options (no third argument)
      
//        console.log("Waiting4Host2PopulateCerts");
//              wait4Hosts2PopulateCerts();
//
//		/*if(data.certificates != null && data.hosts != null) {
//                        for(cert_loop = 0; cert_loop < data.certificates.length; cert_loop++) {
//                                for(host_loop = 0; host_loop < data.hosts.length; host_loop++) {
//                                        if(data.certificates[cert_loop].subject == data.hosts[host_loop].hardware_uuid) {
//                                                data.certificates[cert_loop].subjectName = data.hosts[host_loop].name;
//                                                continue;
//                                        }
//                                }
//                        }
//                }*/
//                console.log("Data Length: " + data.certificates.length);
//                console.log("Data Object: " + data);
//                  log.debug("after certificates_json ws.data: "+Object.toJSON(ws.data));
//        log.debug("after certificates_json data: "+Object.toJSON(data));
//                for(var loop = 0; loop < data.certificates.length; loop++) {
//                        data.certificates[loop].status = "Active";
//                        var now = new Date(event.memo.serverTime);
//                        if(JSON.parse(data.certificates[loop].revoked)) {
//                                data.certificates[loop].status = "Revoked";
//                        } else if(!now.between(new Date(data.certificates[loop].not_before), new Date(data.certificates[loop].not_after))) {
//                                data.certificates[loop].status = 'Expired';
//                        }
//                }
//                view.sync();
//    apiwait("Searching tags...");
    };

    mtwilson.atag.retrieveMainConfiguration = function(eventMemo_not_used) {
        log.debug("retrieveMainConfiguration searching for main...");
        // we get called after all the configurations are retrieved from the server...
        // currently we really only support one "main" configuration 
        // so find it in the list -- should be the only one there
        var i = data.configurations.length;
        var current = null;
        while (i-- && current === null) {
            if (data.configurations[i].name === 'main') {
                current = data.configurations[i];
//                log.debug("found it!");
            }
        }
        log.debug("Found current configuration: " + Object.toJSON(current));
//        data.currentConfiguration.merge(current.jsonContent);
        data.currentConfiguration.merge(current.content);

        // for the configuration form
        mtwilson.rivets.forms['config-form'].input.merge(current.content);

//        data.currentConfiguration.selections = mtwilson.atag.data.selections; // need to have the selection choices for the form, but we don't submit all the seelction names, only the one that is chosen
//        log.debug("Current configuration: "+Object.toJSON(data.currentConfiguration));
        view.sync();
//        ajax.json.get('configurations', {nameEqualTo:'main'}, {datapath:'currentConfiguration'}); // pass parameters as object (serialize=true) and no other options (no third argument)
    };

    mtwilson.atag.storeMainConfiguration = function(input) {
        var report = validate(input);
//        log.debug("storeMainConfiguration validated input (no-op)");
        if (report.isValid) {
            log.debug("storeMainConfiguration input is valid");
            log.debug("the report.input is: " + Object.toJSON(report.input)); // report = {'validator': validator, 'input': model, 'isValid': isValid, 'formId': formId};
        }
//            var clone = report.input.clone(); // or use report.input.cloneJSON() if it has circular references (it shouldn't!) or another way is Object.toJSON(report.input).evalJSON(); 
        log.debug("current configuration: " + Object.toJSON(data.currentConfiguration));
//        data.configurations[0].content.merge(data.currentConfiguration); 
        //      var config = data.configurations[0];
//        delete config.content; // don't send the text content to the server... send only the jsonContent that we edited, and the server will serialize
        var config = {};
//        config.merge(data.currentConfiguration);  // for name, uuid
        config.merge(data.configurations[0]); // for name, uuid   
        config.content.merge(report.input);  // for the updated settings
//        delete config.content.selections; // don't send the selection data (merged into it in retrieveMainConfiguration)
//        delete config.content.tags; // don't send the selection data (merged into it in retrieveMainConfiguration)
        log.debug("modified config: " + Object.toJSON(config));
        log.debug("calling ajax... " + report);
//        ajax.json.put('configurations', config, {'app':report});
        ajax.json.put('configurations', config, {app: {'input': {'name': config.name}}}); // pass {app:report} so it will be passed to the event handler after the request is complete
//        log.debug("returned from ajax...");
//        }
    };


    mtwilson.atag.searchConfigurations = function(input) {
        var report = validate(input);
//    if( report.isValid ) { ... }
        // each section of the tag search form looks like "Name [equalTo|contains] [argument]" so to create the search criteria
        // we form parameters like nameEqualTo=argument  or nameContains=argument
        var fields = ['name', 'contentType'];
        var i;
        for (i = 0; i < fields.length; i++) {
            $('configuration-search-' + fields[i]).name = fields[i] + $F('configuration-search-' + fields[i] + '-criteria'); // this.options[this.selectedIndex].value;
        }

        // first clear search results (otherwise the results we get from server will be appended to them)
        data.configurations.clear();
//        log.debug("cleared data tags: "+Object.toJSON(data.tags));

//        ajax.json.get('tags', {uri:'/tags?' + $(report.formId).serialize()});
        ajax.json.get('configurations', $(report.formId).serialize(true), {callback: mtwilson.atag.retrieveMainConfiguration}); // pass parameters as object (serialize=true) and no other options (no third argument)
//    apiwait("Searching tags...");
    };


    mtwilson.atag.loadCaCerts = function(input) {
        return;
        ajax.json.get('files', {nameEqualTo: 'cacerts'}, {callback: function(eventMemo) {
                var i = data.files.length;
                var current = null;
                while (i-- && current === null) {
                    if (data.files[i].name === 'cacerts') {
                        current = data.files[i];
//                    log.debug("found it! "+Object.toJSON(current));
                    }
                }
                if (current) {
                    $('cacerts-text').update(Base64.decode(current.content));
                }
//        data.currentConfiguration.merge(current.jsonContent);
//        log.debug("Current configuration: "+Object.toJSON(data.currentConfiguration));
//        view.sync();                
            }}); // pass parameters as object (serialize=true) and no other options (no third argument)

    };

    /*
     function storeConfigForm() {
     if( !('form' in MHConfig) ) { MHConfig['form'] = {}; }
     var textInputs = $$('form#config-form input[type="text"]');
     var passwordInputs = $$('form#config-form input[type="password"]');
     for(var i=0; i<textInputs.length; i++) {
     MHConfig['form'][ textInputs[i].id ] = textInputs[i].value;
     }
     for(var i=0; i<passwordInputs.length; i++) {
     MHConfig['form'][ passwordInputs[i].id ] = passwordInputs[i].value;
     }
     }
     
     function fillConfigForm() {
     if( !('form' in MHConfig) ) { return; }
     for(var inputId in MHConfig['form']) {
     try {
     var input = $(inputId);
     if( input.type == "text" || input.type == "password" ) {
     input.value = MHConfig['form'][inputId];
     }
     }
     catch(e) {
     log.warning("Missing configuration input in form: "+e.name+": "+e.message);
     }
     }
     }
     
     function updateKeyTableView() {
     for(var keyname in MHConfig['dek']) {
     var record = MHConfig['dek'][keyname];
     $$('table#key-table-view tbody')[0].insert({bottom:'<tr><td>'+keyname+'</td><td>AES</td><td>128</td><td>unknown</td><td></td></tr>'});
     }
     }
     */

// given a form model (eg mtwilson.rivets.forms['myform']) check each attribute
// which corresponds to a text input, password input, or textarea, and if its value
// is the same as the default display text (from input.js) then clear the value
// Returns:  a copy of the model (so that when we reset the value to empty string
// it doesn't affect the UI at all
// Example:   { 'attr1':'default value', 'attr2':'user defined', 'attr3':'user defined' }
//   if the 'default value' corresponds to 'data-alt' in <input id='input1' data-bind-value='attr1' data-alt='default value'/>
//   then the returned object would be:
//            { 'attr1':'',  'attr2':'user defined', 'attr3':'user defined' }
    /*  *** NOT NEEDED WHEN YOU USE HTML5 PLACEHOLDER ATTRIBUTES... ***
     function cloneWithoutAltText(model) {
     var clone = {};
     for(var p in model) {
     var els = $$('input[data-bind-value='+p+']','password[data-bind-value='+p+']', 'textarea[data-bind-text='+p+']');
     if( els.length > 0 ) {
     for(var i=0; i<els.length; i++) {
     if( els[i].getAttribute('data-alt') && (els[i].getAttribute('data-alt') == model[p]) ) {
     clone[p] = '';
     }
     else {
     clone[p] = model[p];
     }
     }
     }
     else {
     clone[p] = model[p];
     }
     }
     return clone;
     }
     */


    /*
     * This method accepts either the id of a form or a javascript object with input.
     * If a form id is given, the form is validated and the corresponding rivets model
     * is used as input.
     * If a javascript object is given, at this time we don't validate it because the
     * validation is tied to the form and there's no convenient way to reapply the rules
     * to the object.
     */
    mtwilson.atag.updateCertificateAuthority = function(input) {
        var report = validate(input);
        if (report.isValid) {
            alert(jQuery("#alert_valid_ca").text() + ": " + Object.toJSON(report.input));
        }
        else {
            alert(jQuery("#alert_not_valid_ca").text() + ": " + Object.toJSON(report.input));

        }
        //alert("Update CA: "+Object.toJSON(cloneWithoutAltText(input)));
    };



})();  // end mt wilson asset tag module definition


document.observe("dom:loaded", function() {

	// get the authorization token
	getAuthorizationToken();

    // look for a "resources" link to automatically load available server resources; 
    // if not provided then the application should have configured resources via javacript
    var links = $(document.head).select('link');
    var i;
    if (links) {
        // look for rel=resources
        for (i = 0; i < links.length; i++) {
            if (links[i].rel === "resources") {
                console.log("Found resource links at " + links[i].href + " with type " + links[i].type);
                ajax.json.get("resources", null, {uri: links[i].href, datapath: "resources"});
            }
        }
    }
    //i18nInit();
});


function enableClickableAlerts(){
    $('notifications').observe('click', function(event) {
        $('notifications').fade.bind($('notifications')).delay(0);
    });

    /*$$('.msgOK').invoke('observe', 'click', function() {
     this.hide();
     });
    $$('.msgInfo').invoke('observe', 'click', function() {
        this.hide();
    });
    $$('.msgWarn').invoke('observe', 'click', function() {
        this.hide();
    });
    $$('.msgError').invoke('observe', 'click', function() {
        this.hide();
    });*/
}

mtwilson.atag.loadHostsForProvisioning = function(input) {
    ajax.json.get('hosts', {'filter':'false'});
};


function addElement2SelectedHosts(host_id) {
   for(var loop = 0; loop < mtwilson.atag.data.selected_hosts.length; loop++) {
      if(mtwilson.atag.data.selected_hosts[loop].subject == host_id)
         return true;
   }
   mtwilson.atag.data.selected_hosts.push({subject: host_id, status: 'Queued'});
}

function removeElement2SelectedHosts(host_id) {
   for(var loop = 0; loop < mtwilson.atag.data.selected_hosts.length; loop++) {
      if(mtwilson.atag.data.selected_hosts[loop].subject == host_id) 
         mtwilson.atag.data.selected_hosts.splice(loop, 1);
   }
}

var selectedSelectionXML = '';
var fileContentsRead = false;

function getFileContents() {
	var uploadHandle = document.getElementById("fileForUpload");
	var file = "";
	if(uploadHandle.files != undefined) {
		file = uploadHandle.files[0];
	} else {
		file = uploadHandle.value;
	}
	if (file) {
	    var reader = new FileReader();
	    reader.readAsText(file, "UTF-8");
	    reader.onload = function (evt) {
        	var xml = evt.target.result;
		parseSelectionXML(xml);
		fileContentsRead = true;
	    };
	    reader.onerror = function (evt) {
	        //document.getElementById("fileContents").innerHTML = "error reading file";
    	    };
	} else {
	    var fileContents = ieReadFile(file);
	    try{
        	//var xml = evt.target.result;
		parseSelectionXML(fileContents);
		fileContentsRead = true;
	    }catch(Exception){
		//document.getElementById("fileContents").innerHTML = "error reading file";
		alert(jQuery("#alert_provision_select_tag_xml").text());
		return false;
	    }
	}
}

function ieReadFile(filename) 
{
    try
    {
	var reader = new FileReader();
	reader.onloadend = function(){
    // do something with this.result
		return this.result;
	}
	reader.readAsText(filename);

        var fso  = new ActiveXObject("Scripting.FileSystemObject"); 
        var fh = fso.OpenTextFile(filename, 1); 
        var contents = fh.ReadAll(); 
        fh.Close();
	fileContentsRead = true;
        return contents;
    }
    catch (Exception)
    {
        return "Cannot open file :(";
    }
}

function parseSelectionXML(xml) {
	if (window.DOMParser)
	{
		parser=new DOMParser();
		xmlDoc=parser.parseFromString(xml, "text/xml");
	} else { // Internet Explorer
		xmlDoc=new ActiveXObject("Microsoft.XMLDOM");
		xmlDoc.async=false;
		xmlDoc.loadXML(xml); 
	}

	mtwilson.atag.data.selection_details = [];
	var attributes = xmlDoc.getElementsByTagName('attribute');
	for(var loop = 0; loop < attributes.length; loop++) {
		var text = (attributes[loop].getElementsByTagName('text')[0].textContent);
		var split_vals = text.split('=');
		mtwilson.atag.data.selection_details.push({
			id: loop,
			kv_attribute_name: split_vals[0],
			kv_attribute_value: split_vals[1]
		});
	}
	selectedSelectionXML= xml;
        mtwilson.rivets.views['provision-sel-details'].sync();
}

var hostProvFailed = false;
var hostProvRespCount = 0;

function provisionTags() {
	hostProvFailed = false;
	hostProvRespCount = 0;

	var selected_hosts = mtwilson.atag.data.selected_hosts;
	if(selected_hosts.length == 0) {
		alert(jQuery("#alert_provision_select_server").text());
		return false;
	}

	if(selectedSelectionXML == '') {
                alert(jQuery("#alert_provision_upload_tag_xml").text());
		return false;
	}
        mtwilson.rivets.views['provision-sel-table'].sync();
	$('provisionTagFormDiv').toggle();
	$('provisionTagProgDiv').toggle();
	for(var loop = 0; loop < selected_hosts.length; loop++) {
            ajax.custom.post('certificateRequests', selectedSelectionXML, {app: selected_hosts[loop].subject, contentType: 'application/xml', accept: 'application/xml', func: 'bulk_provisioning', next_action: 'deployCertificates'}, {subject: selected_hosts[loop].subject});
            updateHostProvisioningStatus(selected_hosts[loop].subject, 'Request sent', true);
	}
}

function updateHostProvisioningStatus(subject, status_str, dontUpdateCount) {
	if(typeof dontUpdateCount == 'undefined') {
		dontUpdateCount = false;
	}
	var selected_hosts = mtwilson.atag.data.selected_hosts;
	for(var loop = 0; loop < selected_hosts.length; loop++) {
		if(selected_hosts[loop].subject == subject) {
			mtwilson.atag.data.selected_hosts[loop].status = status_str;
			if(dontUpdateCount == false)
				hostProvRespCount++;
			break;
		}
	}
        return;
	if( hostProvRespCount == selected_hosts.length) {
		messageStr = 'Done!';
		document.getElementById('hostProgressMessage').style.color = 'green';
		if(hostProvFailed) {
			document.getElementById('hostProgressMessage').style.color = 'red';
			messageStr = 'Done with errors. Please retry';
		}
		document.getElementById('hostProgressMessage').innerHTML = messageStr;
		$('hostProgressMessage').toggle();
	}
}

function openProvisionSelectionOptions(id) {
	selectedSelectionXML = '';
	mtwilson.atag.data.selection_details = [];
	jQuery('.prov_sel_option').hide();
	jQuery('#'+ id).show();
	jQuery('.prov_choose_sel_link').removeClass('prov_choose_sel_link_selected');
	jQuery('#'+ id + '_link').addClass('prov_choose_sel_link_selected');
	jQuery('.selection_entry').removeClass('highlightSelectedSelection');
	var fileControl = jQuery('#fileForUpload');
	fileControl.replaceWith(fileControl.clone());
}

function getSelectedSelectionDetails(selection_id) {
	disable_sel_render=true; 
	selectedSelectionXML="";
        mtwilson.atag.data.selection_details = [];
	xmlhttp=new XMLHttpRequest();
	xmlhttp.onreadystatechange=function() {
		if (xmlhttp.readyState==4 && xmlhttp.status==200) {
			var requestObject = xmlhttp.responseText;
			parseSelectionXML(requestObject);
			jQuery('.selection_entry').removeClass('highlightSelectedSelection');
			jQuery('#' + selection_id).addClass('highlightSelectedSelection');
		}
	};
	xmlhttp.open("GET","/mtwilson-portal/v2proxy/tag-selections/" + selection_id + ".xml?rand=" + Math.random(),true);
	xmlhttp.send();            

}

var certNameRetrieveStatusUpdated = false;

function wait4Hosts2PopulateCerts() {
        var atag = mtwilson.atag;
        var data = atag.data;
        if(data.hosts == null || data.certificates == null || data.hosts.length == 0  || data.certificates.length == 0) {
                for(cert_loop = 0; cert_loop < data.certificates.length; cert_loop++) {
                        data.certificates[cert_loop].subjectName = 'fetching..';
                }
                if(!certNameRetrieveStatusUpdated) {
                        atag.view.sync();
                        certNameRetrieveStatusUpdated = true;
                }
                // Wait for a few millinseconds for the next check
                setTimeout(wait4Hosts2PopulateCerts, 100)
        } else {
                populateCertsWithHostName();

        }
}

function populateCertsWithHostName() {
        var atag = mtwilson.atag;
        var data = atag.data;
        var isNameSet = false;
        for(cert_loop = 0; cert_loop < data.certificates.length; cert_loop++) {
                isNameSet = false;
                for(host_loop = 0; host_loop < data.hosts.length; host_loop++) {
                        if(data.certificates[cert_loop].subject == data.hosts[host_loop].hardware_uuid) {
                                data.certificates[cert_loop].subjectName = data.hosts[host_loop].name;
                                isNameSet = true;
                                continue;
                        }
                }
                if(!isNameSet) {
                        data.certificates[cert_loop].subjectName = 'Not Available';
                }
        }
        ajax.view.sync();
}


function populateCertsInfoToTable(certsInfo) {
    var  str = "<table class='tableDisplayBind' id='certificate-browse-table' cellspacing='0' cellpadding='0'><tbody>";
    console.log("CertsInfo Received: "+certsInfo);
    console.log("CertsInfo Received Length: "+certsInfo.length);
    for (item = 0; item < certsInfo.length; item++) {

        var classValue = null;
        if (item % 2 === 0) {
            classValue = 'evenRow';
        } else {
            classValue = 'oddRow';
        }
        console.log("Item value:"+item);
        console.log("Read Cert:" + certsInfo[item].subject);
//        console.log("Read Cert:" + certsInfo[item].subject);
        console.log("String created " + str);
        
        str += "<tr class='"+classValue+"'>"+
                    "<td align='center'>"+certsInfo[item].subject+"</td>"+
                    "<td align='center'>"+certsInfo[item].issuer+"</td>"+
                    "<td align='center'>"+certsInfo[item].notBefore+"</td>"+
                    "<td align='center'>"+certsInfo[item].notAfter+"</td>"+
                    "<td align='center'>"+certsInfo[item].status+"</td>"+
                    "<td align='center'>"+certsInfo[item].sha1+"</td>"+
                    "<td align='center'>"+certsInfo[item].sha256+"</td>"+
                    "<td align='center'><a filename='"+certsInfo[item].id+"' href='' onmouseover='$(this).download = $(this).getAttribute('filename') + '.crt';$(this).href='data:application/octet-stream;base64,'+($(this).next('span').innerHTML);'  data-bind-filename='item.subject'>Download</a><span style='display:none;' data-bind-text='item.certificate'></span> <br /><br />\n\
                                        <a filename='"+certsInfo[item].id+"' href='#' onclick=ws.revokeCertificate('"+certsInfo[item].id+"');>Revoke</a></td></tr>"+
                    "";
//           <a href='' onmouseover='$(this).download = $(this).getAttribute('filename') + '.crt';$(this).href='data:application/octet-stream;base64,'+($(this).next('span').innerHTML);'  data-bind-filename='item.subject'>Download</a><span style='display:none;' data-bind-text='item.certificate'></span> <br /><br />
//                                            <a data-bind-uuid='item.id' href='#' data-i18n='link.import' onclick='javascript:ws.deployCertificate(this.getAttribute('uuid')); return false;'>Import</a>&nbsp;
//                                            <a data-bind-uuid='item.id' href='#' data-i18n='link.revoke' onclick='javascript:ws.revokeCertificate(this.getAttribute('uuid')); return false;'>Revoke</a>
//        str += '<tr class="' + classValue + '" hostID="' + certsInfo[item].hostID + '" id="host_div_id_' + certsInfo[item].hostName.replace(/\./g, '_') + '">' +
//                '<td align="center" class="row1"></td>' +
//                '<td class="row2">' + certsInfo[item].hostName + '</td>' +
//                '<td align="center" class="row3"><img border="0" src="' + certsInfo[item].osName + '"></td>';
//        var value = certsInfo[item].hypervisorName != "" ? '<img border="0" src="' + certsInfo[item].hypervisorName + '">' : '';
//        str += '<td align="center" class="row4">' + value + '</td>';
        //TODO : 
        // Loaction Policy 
        //according to email on Fri 9/14/2012 10:21 AM
        //Item: 5
        //To remove the location from main page commnet thr below line and un uncommnet the next line 
        //value = certsInfo[item].location != undefined ? certsInfo[item].location : "";
        //value="";
//        str += '<td align="center" class="row5"><img border="0" src="' + certsInfo[item].assetTagStatus + '"></td>' +
//                '<td align="center" class="row6"><img border="0" src="' + certsInfo[item].biosStatus + '"></td>' +
//                '<td align="center" class="row7"><img border="0" src="' + certsInfo[item].vmmStatus + '"></td>' +
//                '<td align="center" class="row8"><img border="0" src="' + certsInfo[item].overAllStatus + '"></td>';
        /*if (!(certsInfo[item].overAllStatusBoolean)) {
         str+='<td class="rowHelp"><input type="image" onclick="showFailureReport(\''+certsInfo[item].hostName+'\')" src="images/helpicon.png" alt="Failure Report"></td>';
         }else {
         str+='<td class="rowHelp"></td>';
         
         }*/

//        str += '<td class="row9">' + certsInfo[item].updatedOn + '</td>' +
//                '<td nowrap align="center" class="row10"><input class="tableButton" type="button"  value="Refresh" onclick="fnUpdateTrustForHost(this)"></td>' +
//                '<td align="center" class="row11"><a><img src="images/trust_assertion.png" onclick="fnGetTrustSamlDetails(\'' + certsInfo[item].hostName + '\')"/></a></td>' +
//                '<td class="rowHelp"><input type="image" onclick="showFailureReport(\'' + certsInfo[item].hostName + '\')" src="images/trust_report.png" alt="Failure Report"></td>' +
//                '<td class="row12">';
//
//        if (certsInfo[item].errorMessage != null) {
//            str += '<textarea class="textAreaBoxClass" cols="20" rows="2" readonly="readonly">' + certsInfo[item].errorMessage + '</textarea>';
//        }
//        str += '</td>' +
//                '</tr>';
//
//        str += '<tr style="display: none;">';
//        str += '<td class="' + classValue + '" colspan="13">' +
//                '<div class="subTableDiv" style="text-align: left;">This feature is currently not implemented.</div>' +
//                '</td>';
    }
    str += "</tbody></table>";
    document.getElementById('certInfo').innerHTML = str;
    //$('#certInfo').html(str);
}
